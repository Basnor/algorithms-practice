## ПРИНЦИП РАБОТЫ

Я реализовала алгоритм для определения оптимальны ли карта железных дорог в стране X. Суть алгоритма в том, чтобы на основе имеющейся карты и типа дороги построить граф. Для этого я представила дороги в городах i + 1, i + 2, n в качестве вершин, а тип дороги B и R в качестве веса ребра. Для того чтобы определить является ли карта оптимальной, я перевернула все ребра одного веса и проверила граф на наличие цикла.

По условию задачи, двигаться можно только от города с меньшим номером к городу с большим номером. Это значит, что в графе без преобразований, не существует такого города, в который можно попасть c предыдущего города. Иными словами, граф является однонаправленным и ациклическим. При инвертации одного подмножества ребер возможны два сценария:

1. Граф перестанет быть однонаправленным, но останется ациклическим. Это означает, что есть иная связь, позволяющая добраться до каждой из вершин.
2. Граф перестанет быть однонаправленным и ациклическим. Это означает, что в большую вершину инвертированного ребра невозможно добраться иными способами и граф не оптимальный.

Если получившийся граф имеет цикл, значит граф не оптимальный. Это можно представить на неоптимальной карте из 3-х городов:

1 : 2 - R  
1 : 3 - B  
2 : 3 - R

Как видим, в город 3 можно добраться по маршруту R и B. При этом, если развернуть ребро с весом B, то получем цикл 1 - 2 - 3 - 1:

1 : 2 - R  
2 : 3 - R  
3 : 1 - B

Если в получившимся графе нет цикла, значит граф считается оптимальным.

Более подробно можно изучить теорию и примеры нахождения цикла в графе:
https://www.geeksforgeeks.org/detect-cycle-in-a-graph/

## ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ

Граф представлено в виде класса Graph, где содержится список смежности р имеющихся вершин и массива исходящих из них вершин. Все ребра с весом R сразу переворачиваются.

Для нахождения цикла используется алгоритм Кана, где используется топологическая сортировка вершин ациклического ориентированного графа. В массиве inDegree хранятся количество вхождений в каждую вершину. При обходе графа в ширину, уменьшаем это количество до тех пор, пока inDegree каждой вершины не будет 0. Если количество обходов равно количеству ребер, значит в графе нет циклов.

## ВРЕМЕННАЯ СЛОЖНОСТЬ

Сложность алгоритма Кана O(V + E). Так как наибольшие затраты приходятся на алгоритм нахождения цикла, который состоит из прохода всех вершин и ребер.

## ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ

Пространственная сложность составляет O(V), где V - количество вершин. Так как нам нужно держать в памяти:

-   массив вхождений размера V;
-   матрицу смежностей размера V;
-   стек обратных вызовов размера V.
