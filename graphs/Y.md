## ПРИНЦИП РАБОТЫ

Я реализовала алгоритм Прима для нахождения максимального остовного дерева. Суть алгоритма Прима сводится к жадному перебору рёбер из определенного множества. На входе имеется пустой подграф, который достраивается до потенциального максимального остовного дерева. Ребра уже собранного подмножества остова хранятся в куче с поддержанием максимума. Это позволяет оптимально выбирать ребро с максимальным весом.

Работу алгоритма Прима можно описать с помощью следующих шагов:

Шаг 1: Определяется произвольная вершина в качестве начальной вершины подграфа.
Шаг 2. Выполняются шаги с 3 по 5, пока в куче есть вершины.
Шаг 3: Находятся ребра, соединяющие рассматриваемую вершину дерева с крайними вершинами.
Шаг 4: Находится максимум среди этих ребер.
Шаг 5: Увеличивается суммарный вес на вес найденного ребра.
Шаг 6. Возвращается вес или ошибку при наличии нескольких компонент связности.

Более подробно можно изучить теорию и примеры тут:
https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/

По условию, граф неориентированный, в нем могут оказаться петли и кратные ребра, а также он может оказаться несвязным.

## ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ

Остовное дерево представлено в виде списка смежности реализованного с помощью массива из имеющихся вершин и массива исходящих из них вершин с весом ребра соединяющим их. Алгоритм Прима реализован на основе PriorityQueue, который содержит функциональность для добавления и извлечения максимального элемента. Подробнее об этой реализации можно почитать [тут](https://github.com/Basnor/algorithms-practice/blob/main/trees/Y.md).

Посещенные вершины хранятся в массиве visited. Этот массив позволяет определить наличие в графе нескольких компонент связности и избежать зацикливания в петлях.

## ВРЕМЕННАЯ СЛОЖНОСТЬ

Сложность алгоритма Прима для нахождения максимального остовного дерева сортировки составляет O(E \* log(E)), где E - число ребер. Так как наибольшие затраты приходятся на операции удаления и извлечения вершин.

## ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ

O(V^2) where V is the number of vertex

Пространственная сложность составляет O(V^2), где V - количество вершин. Так как нам нужно держать в памяти:

-   матрицу смежности размера V;
-   массив вершин размера V.
