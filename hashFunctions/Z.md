## ПРИНЦИП РАБОТЫ

Я реализовала хеш-таблицу, которая поддерживает следующие операции:

-   put key value — добавление пары ключ-значение. Если заданный ключ уже есть в таблице, то соответствующее ему значение обновляется.
-   get key – получение значения по ключу. Если ключа нет в таблице, то вывести «None». Иначе вывести найденное значение.
-   delete key — удаление ключа из таблицы. Если такого ключа нет, то вывести «None», иначе вывести хранимое по данному ключу значение и удалить ключ.

Разрешение коллизий происходит с помощью метода цепочек. Посмотреть реализацию с помощью метода открытой адресации можно [тут](https://github.com/Basnor/algorithms-practice/blob/main/hashFunctions/ZChains.js).

Все операции выполняются за O(1) в среднем.

## ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ

Хэш-таблица реализована в виде класса, в котором содержится функциональность для добавления, получения и удаления записей из таблицы. Записи таблицы хранятся в виде связного списка, который позволяет разрешать коллизии.

Связный список представляет собой класс, который хранит ссылку на head — голову связного списка, состоящего из ключа и значения. Элементы связного списка представляют собой узел состоящий из значения и ссылки на следующий элемент. В классе связного списка реализована функциональность для получения, поиска и удаления по значению ключа.

Для добавления ключа key, которого ещё нет в хеш-таблице, выполняем следующую последовательность:

1. Вычисляем значение хеш-функции ч=hash(key) от добавляемого объекта.

    > Ключ представляет собой целое число, не превосходящее 10^9 по модулю, и может быть отрицательным. Поэтому, хэш приводим к модулю абсолютного значения исходного ключа.

2. По значению хеш-функции получаем индекс записи в таблице i=x%len(H).
3. В массиве H находим H[i] — ссылка на голову списка ключей.
4. Вставляем элемент в связный список.

При поиске или удалении объекта, выполняем следующую последовательность:

1. Вычисляем значение хеш-функции x=h(k) от ключа.
2. По значению хеш-функции получаем индекс корзины i=x%len(H).
3. Находим H[i] — ссылка на голову списка ключей.
4. Выполняем поиск ключа в связном списке и при необходимости удаляем его.

## ВРЕМЕННАЯ СЛОЖНОСТЬ

Все операции хэш-функции выполняются в среднем за O(1). Помимо времени на вычисление хеш-функции нам потребуется O(1) для добавления этого элемента в начало цепочки. Для эффективного использования хеш-таблиц, нужно исключить дубли. Поэтому, сложность операций добавления, поиска и удаления будет одинаковой, так как узкое место каждой из задач — поиск элемента в цепочке. Сложность операции в лучшем случае составит O(1), в худшем O(n).

Среднее время исполнения операций в хеш-таблице зависит от того, как часто случаются коллизии: чем реже они происходят, тем быстрее в среднем выполняется операция.

> Предположим, что наша хеш-функция — равномерная, тогда среднюю сложность операций в хеш-таблице можно принять за O(1+α), где α — коэффициент заполнения (англ. fill factor или load factor).

Итого, временная сложность n операций по работе с равномерно заполненной хэш-функцией составит O(n).

## ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ

Хэш-функция представляет собой массив размера M из элементов связного списка. Для хранения такого массива нужно O(M \* n) памяти, где n — количество элементов в связном списке. Так как M постоянна, пространственную сложность можно оценить как O(n).
