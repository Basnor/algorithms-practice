## ПРИНЦИП РАБОТЫ

Я реализовала функциональность на основе стандартных Set и Map коллекций JavaScript, которая позволяет на основе n документов, вывести 5 самых релевантных документов для m запросов. Документ и запрос представляют собой набор слов.

Релевантность документа оценивается следующим образом: для каждого уникального слова из запроса берётся число его вхождений в документ, полученные числа для всех слов из запроса суммируются. Итоговая сумма и является релевантностью документа. Чем больше сумма, тем больше документ подходит под запрос.

Сортировка документов на выдаче производится по убыванию релевантности. Если релевантности документов совпадают – то по возрастанию их порядковых номеров во входных данных.

## ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ

Все получаемые документы вносятся в Map коллекцию слов с помощью функции addWords. Ключем в коллекции является слово, значением - массив из объектов с количеством встретившихся слов в каждом документе.

Подсчет релевантных документов на основе полученных запросов осуществляется в функции getRelevance. Функция создает массив размера n состоящий из значений количества найденных совпадений, затем сортирует и выводит индексы топ 5 самых релевантных документов.

## ВРЕМЕННАЯ СЛОЖНОСТЬ

Для заполнения коллекций Map и Set потребуется O(n \* d + m \* r \* n) времени, где d — количество слов в документе, r — количество слов в запросе.

> Так как количество символов в документе не превосходит 1000, а в запросе не превосходит 100, можем считать, что значения (1 ≤ n ≤ 10^4) и (1 ≤ m ≤ 10^4) значительно превосходят. Следовательно, мы можем опустить d и r.

Также, потребуется O(n) для фильтрации и O(n \* log n) для сортировки (стандартный метод использует сортировку ["in place"](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)).

Итого, суммарная сложность составит O(n + m \* n \* (2n + log n)).

## ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ

Для хранения коллекции слов документа потребуется O(n \* d) памяти, где d можем откинуть. Для хранения коллекции слов запроса потребуется O(m \* r) памяти. Так как для каждого запроса создается своя коллекция, а прошлая попадает в сборщик мусора, то на итоговую сложность коллекция запрос не повлияет.

Итоговая пространственная сложность составит O(n).
