## ПРИНЦИП РАБОТЫ

Я реализовала алгоритм для расчета наибольшего общего префикса распакованных строк.

Изначально, даны строки в запакованном виде. Определить запакованную строку (ЗС) можно рекурсивно:

-   ЗС является строкой только из строчных букв английского алфавита.
-   Если A и B — корректные ЗС, то и AB является ЗС.
-   Если A – ЗС, а n — однозначное натуральное число, то n[A] тоже ЗС.
-   Запись n[A] означает, что при распаковке строка A записывается подряд n раз.

Пример:
3[a]2[r2[t]] => aaarttrtt.

## ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ

Алгоритм состоит из трех частей:

-   Нахождение всех паттернов n[A] одного уровня в строке
-   Итерация по всем уровням вложенности паттернов n[A] и распаковка строки
-   Нахождение наибольшего общего префикса строк

Реализованная функция findPatterns находит все паттерны одного уровня с помощью регулярного выражения. Функция update рекурсивно итерируется по всем найденным паттернам и возвращает распакованную строку. Функция findPrefix находит общий префикс сдвигом строк.

## ВРЕМЕННАЯ СЛОЖНОСТЬ

Сложность распаковки строк составляет O(n \* L \* K \* M), где n - длина строк, L - уровень вложенности, a K - количество паттернов одного уровня в строке, M - количество строк. L \* K можно упростить до количества паттернов в строке - P, тогда сложность будет составлять O(n \* P \* M).

Для нахождения наибольшего общего префикса необходимо O(n \* M), где M - количество строк.

Итого, пространственную сложность можно представить в виде O(n \* M \* P).

## ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ

Пространственная сложность составляет O(n \* P).
