## ПРИНЦИП РАБОТЫ

Я реализовала "in-place" модификацию быстрой сортировки. В функции quickSortInPlace выбирается опорный элемент (pivot) и два указателя left и right на границы отрезка. Затем,двигаем левый указатель вправо до тех пор, пока он не будет указывать на элемент, меньший опорного. Аналогично будем двигать правый указатель влево, пока он стоит на элементе, превосходящем опорный. Элементы, на которых стоят указатели, нарушают порядок. Мы меняем их местами используя функцию swap().

В итоге получим, что левее от left все элементы точно принадлежат первой группе, а правее от right — второй. Будем повторять это действие до тех пор, пока left и right не столкнутся.

## ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ

Исходный массив представляет собой массив объектов с данными. Алгоритм берет из него pivot объект случайным образом и сравнивает его с с объектами по left и right указателям. Если нашлись элементы стоящие в неверном порядке относительно pivot, меняем их местами. Как только указатели столкнулись, делим исходный участок по индексу на котором столкнулись элементы и рекурсивно сортируем их. Базовым случаем считаем участок из одного элемента.

## ВРЕМЕННАЯ СЛОЖНОСТЬ

Для нахождения элементов в некорректном порядке относительно pivot потребуется n итераций, что выполнится за O(n) времени. Мы не может предсказать количество рекурсивных уровней, так как за опорный элемент принимается средний элемент отрезка. Но так как pivot выбирается случайным способом, мы можем гарантировать, что глубина рекурсии составит O(log n) на любых данных.

Итого, временная сложность составляет O(n log n).

## ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ

Модификация быстрой сортировки "in-place" не может потреблять больше O(n) дополнительной памяти для промежуточных данных. Это объясняется тем, что нам нужно держать в памяти:

-   массив размера n;
-   указатели на обратные вызовы рекурсивных функций глубиной log n (можно откинуть);
-   константы (можно откинуть).
