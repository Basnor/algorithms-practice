## ПРИНЦИП РАБОТЫ

Я реализовала алгоритм поиска, который использует два указателя. Функция brokenSearch принимает на вход массив и искомый элемент. Дальше, делим массив пополам и сравниваем участки слева и справа. Если один из получившихся участков отсортирован, проверяем принадлежит ли ему искомый элемент. Если элемент принадлежит отсортированному участку, отбрасываем противоположный. Если элемент не принадлежит отсортированному участку, отбрасываем отсортированный участок.

## ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ

Исходный массив представляет собой кольцевой буфер с отсортированными данными, который сдвинут относительно исходной последовательности. Это означает, что выбрав случайный элемент, все элементы слева или справа окажутся отсортированными. Определив принадлежность отсортированному участку, можно отбросить левую или правую половину за О(1).

## ВРЕМЕННАЯ СЛОЖНОСТЬ

Алгоритм находит элемент за O(log n), потому что на каждой итерации мы делим массив пополам и изменяем только значения указателей.

## ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ

Пространственная сложность составляет O(n), так как нам нужно держать в памяти:

-   массив размера n;
-   указатели (можно откинуть).
